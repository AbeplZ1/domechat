<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DomeChat Chat</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
  <div id="topbar">
    <div class="follow-badge">follow domechat.live on TikTok</div>
    <div>
      <button id="nextBtn">Find Next</button>
      <button id="disconnectBtn">Disconnect</button>
    </div>
  </div>

  <div id="videoPlaceholder">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div id="chatArea">
    <div id="chatMessages" aria-live="polite"></div>
    <div id="typingIndicator"></div>
    <div id="controlsRow">
      <input id="messageInput" placeholder="Type your message..." autocomplete="off"/>
      <button id="sendBtn" disabled>Send</button>
    </div>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
// Utils
const toB64=(buf)=>btoa(String.fromCharCode(...new Uint8Array(buf)));
const fromB64=(b64)=>{const bin=atob(b64);const arr=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i);return arr.buffer;};
const chat = document.getElementById('chatMessages');
function addMessage(text,self=false){ const d=document.createElement('div'); d.textContent=text; if(self) d.classList.add('self'); const t=document.createElement('span'); t.className='timestamp'; t.textContent=new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); d.appendChild(t); chat.appendChild(d); chat.scrollTop=chat.scrollHeight; }

// E2EE
let cryptoKey=null, keyPair=null;
async function genECDH(){ keyPair=await crypto.subtle.generateKey({name:'ECDH',namedCurve:'P-256'},true,['deriveKey']); const raw=await crypto.subtle.exportKey('raw',keyPair.publicKey); return toB64(raw); }
async function importPeer(pubB64){ const raw=fromB64(pubB64); const peer=await crypto.subtle.importKey('raw',raw,{name:'ECDH',namedCurve:'P-256'},true,[]); cryptoKey=await crypto.subtle.deriveKey({name:'ECDH',public:peer},keyPair.privateKey,{name:'AES-GCM',length:256},false,['encrypt','decrypt']); }
async function encryptText(t){ const iv=crypto.getRandomValues(new Uint8Array(12)); const enc=new TextEncoder().encode(t); const c=await crypto.subtle.encrypt({name:'AES-GCM',iv},cryptoKey,enc); return {iv:toB64(iv.buffer),data:toB64(c)}; }
async function decryptText(p){ const iv=fromB64(p.iv); const data=fromB64(p.data); const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv:iv.slice(0)},cryptoKey,data); return new TextDecoder().decode(pt); }

// Sockets
const socket = io();
const params = new URLSearchParams(location.search);
const topic = params.get('topic') || '';

// Media
let localStream=null;
const localVideo=document.getElementById('localVideo');
const remoteVideo=document.getElementById('remoteVideo');
async function getLocalStream(){
  if (localStream) return localStream;
  const variants = [
    { video:{ facingMode:'user', width:{ideal:1280}, height:{ideal:720} }, audio:true },
    { video:true, audio:true },
    { video:{ facingMode:'user' }, audio:true }
  ];
  for (const c of variants){
    try{ localStream = await navigator.mediaDevices.getUserMedia(c); localVideo.srcObject = localStream; return localStream; }catch(e){ console.warn('gUM failed', c, e); }
  }
  throw new Error('Unable to access camera/mic');
}
// Always show preview
getLocalStream().catch(()=> addMessage('Camera/mic blocked. Check site permissions.'));

// WebRTC: Perfect Negotiation
let pc;
let makingOffer = false;
let ignoreOffer = false;
let isPolite = false;
let hasPartner = false;

const ICE = { iceServers: [ { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] } ] };

function createPC(){
  pc = new RTCPeerConnection(ICE);
  localStream?.getTracks().forEach(t=> pc.addTrack(t, localStream));
  pc.ontrack = e => {
    if (e.streams && e.streams[0]) {
      remoteVideo.srcObject = e.streams[0];
      remoteVideo.play().catch(()=>{});
    }
  };
  pc.onicecandidate = ({candidate}) => { if (candidate && hasPartner) socket.emit('signal', {type:'ice', candidate}); };
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'failed') { pc.restartIce(); }
  };
  pc.onnegotiationneeded = async () => {
    try {
      makingOffer = true;
      await pc.setLocalDescription(await pc.createOffer());
      socket.emit('signal', {type:'sdp', description: pc.localDescription});
    } catch (err) {
      console.warn('negotiation error', err);
    } finally {
      makingOffer = false;
    }
  };
}

socket.on('roles', ({polite, peerId})=>{
  isPolite = !!polite;
});

socket.on('waiting', m => addMessage(m));

socket.on('partnerFound', async ()=>{
  hasPartner = true;
  chat.textContent='';
  addMessage('You found a new partner!');
  if (!pc) createPC();
  const pub = await genECDH(); socket.emit('ecdh-public', pub);
});

socket.on('partnerDisconnected', ()=>{ hasPartner=false; addMessage('Partner disconnected.'); });
socket.on('forceDisconnect', ()=>{ hasPartner=false; addMessage('Partner disconnected.'); });

socket.on('signal', async ({type, description, candidate})=>{
  if (!pc) createPC();
  try {
    if (type === 'sdp') {
      const offerCollision = (description.type === 'offer') && (makingOffer || pc.signalingState !== 'stable');
      ignoreOffer = !isPolite && offerCollision;
      if (ignoreOffer) return;

      await pc.setRemoteDescription(description);
      if (description.type === 'offer') {
        // ensure we have local media
        await getLocalStream();
        // if tracks were not added yet (first-time), add now
        if (pc.getSenders().length === 0) {
          localStream.getTracks().forEach(t=> pc.addTrack(t, localStream));
        }
        await pc.setLocalDescription(await pc.createAnswer());
        socket.emit('signal', {type:'sdp', description: pc.localDescription});
      }
    } else if (type === 'ice') {
      try { await pc.addIceCandidate(candidate); } catch (err) {
        if (!ignoreOffer) console.warn('addIceCandidate failed', err);
      }
    }
  } catch (err) {
    console.warn('signal handling error', err);
  }
});

socket.on('ecdh-public', async (peer)=>{
  try{
    await importPeer(peer);
    document.getElementById('sendBtn').disabled=false;
    document.getElementById('messageInput').disabled=false;
  }catch(e){ console.error('ECDH', e); }
});

// init
socket.emit('setTopic', topic);

// typing and text
const typing = document.getElementById('typingIndicator');
socket.on('partnerTyping', ()=>{ if(!hasPartner) return; typing.textContent='Partner is typing...'; setTimeout(()=>typing.textContent='',1200); });
const sendBtn=document.getElementById('sendBtn');
const msgIn=document.getElementById('messageInput');
sendBtn.onclick = async ()=>{
  const txt = msgIn.value.trim();
  if(!txt || !hasPartner || !cryptoKey) return;
  const payload = await encryptText(txt);
  socket.emit('enc-message', payload);
  const d=document.createElement('div'); d.textContent=txt; d.classList.add('self'); chat.appendChild(d); chat.scrollTop=chat.scrollHeight; msgIn.value='';
};
msgIn.addEventListener('keypress', e=>{ if(e.key==='Enter') sendBtn.click(); else if(hasPartner) socket.emit('typing'); });

document.getElementById('nextBtn').onclick=()=>{ if (hasPartner) socket.emit('next'); else socket.emit('setTopic', topic); };
document.getElementById('disconnectBtn').onclick=()=>{ if (hasPartner) socket.emit('disconnectPartner'); hasPartner=false; location.href='/'; };
</script>
</body>
</html>
