
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DomeChat Chat</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
  <div id="topbar">
    <div class="follow-badge">follow domechat.live on TikTok</div>
    <div>
      <button id="streamBtn" title="Streamer mode">Streamer: Off</button>
      <button id="reportBtn" title="Report (nudity)">Report</button>
      <button id="blockBtn" title="Block">Block</button>
      <button id="nextBtn">Find Next</button>
      <button id="disconnectBtn">Disconnect</button>
    </div>
  </div>

  <div id="videoPlaceholder">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div id="chatArea">
    <div id="chatMessages" aria-live="polite"></div>
    <div id="typingIndicator"></div>
    <div id="controlsRow">
      <input id="messageInput" placeholder="Type your message..." autocomplete="off"/>
      <button id="sendBtn" disabled>Send</button>
    </div>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
const chat = document.getElementById('chatMessages');
function logUI(msg){ const d=document.createElement('div'); d.style.opacity=.7; d.textContent=msg; chat.appendChild(d); chat.scrollTop=9e9; }
function addMessage(text,self=false){ const d=document.createElement('div'); d.textContent=text; if(self) d.classList.add('self'); const t=document.createElement('span'); t.className='timestamp'; t.textContent=new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); d.appendChild(t); chat.appendChild(d); chat.scrollTop=chat.scrollHeight; }
const toB64=(buf)=>btoa(String.fromCharCode(...new Uint8Array(buf)));
const fromB64=(b64)=>{const bin=atob(b64);const arr=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i);return arr.buffer;};

let cryptoKey=null, keyPair=null;
async function genECDH(){ keyPair=await crypto.subtle.generateKey({name:'ECDH',namedCurve:'P-256'},true,['deriveKey']); const raw=await crypto.subtle.exportKey('raw',keyPair.publicKey); return toB64(raw); }
async function importPeer(pubB64){ const raw=fromB64(pubB64); const peer=await crypto.subtle.importKey('raw',raw,{name:'ECDH',namedCurve:'P-256'},true,[]); cryptoKey=await crypto.subtle.deriveKey({name:'ECDH',public:peer},keyPair.privateKey,{name:'AES-GCM',length:256},false,['encrypt','decrypt']); }
async function encryptText(t){ const iv=crypto.getRandomValues(new Uint8Array(12)); const enc=new TextEncoder().encode(t); const c=await crypto.subtle.encrypt({name:'AES-GCM',iv},cryptoKey,enc); return {iv:toB64(iv.buffer),data:toB64(c)}; }
async function decryptText(p){ const iv=fromB64(p.iv); const data=fromB64(p.data); const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv:iv.slice(0)},cryptoKey,data); return new TextDecoder().decode(pt); }

const socket = io();
const params = new URLSearchParams(location.search);
const topic = (params.get('topic')||'').trim();

// Dynamic ICE (Twilio) with fallback
let ICE = { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] };
(async () => {
  try {
    const r = await fetch('/ice', { cache: 'no-store' });
    const list = await r.json();
    if (Array.isArray(list) && list.length) ICE = { iceServers: list };
  } catch {}
})();

const BLOCK_KEY = 'dome_blocked_ids';
const getBlocked = ()=> new Set(JSON.parse(localStorage.getItem(BLOCK_KEY)||'[]'));
const setBlocked = (s)=> localStorage.setItem(BLOCK_KEY, JSON.stringify([...s]));
const isBlocked = (id)=> getBlocked().has(id);

// Local preview
let localStream=null;
const localVideo=document.getElementById('localVideo');
const remoteVideo=document.getElementById('remoteVideo');

async function ensureLocal(){
  if (localStream) return localStream;
  try {
    localStream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'user', width:{ideal:1280}, height:{ideal:720} },
      audio:true
    });
    localVideo.srcObject = localStream;
    localVideo.play().catch(()=>{});
    logUI('✅ Camera ready');
    return localStream;
  } catch (e){
    console.warn('getUserMedia failed', e);
    addMessage('Camera/mic blocked or unavailable. Click the padlock in the address bar and allow camera/mic. Also ensure HTTPS.');
    throw e;
  }
}
ensureLocal();

// Peer connection
let pc, makingOffer=false, ignoreOffer=false, isPolite=false, hasPartner=false, currentPartnerId=null;
const pendingCandidates = [];

function preferVP8(){
  try{
    const sendCaps = RTCRtpSender.getCapabilities('video');
    if (!sendCaps) return;
    const vp8 = sendCaps.codecs.filter(c => /video\/VP8/i.test(c.mimeType));
    const trans = pc.getTransceivers().find(t => t.sender && t.sender.track && t.sender.track.kind==='video');
    if (trans && vp8.length) trans.setCodecPreferences(vp8);
  } catch(e){}
}

async function createPC(){
  pc = new RTCPeerConnection(ICE);
  pc.onicecandidate = ({candidate}) => { if (candidate && hasPartner) socket.emit('signal', {type:'ice', candidate}); };
  pc.ontrack = e => { if (e.streams && e.streams[0]) { remoteVideo.srcObject = e.streams[0]; remoteVideo.play().catch(()=>{}); } };
  pc.oniceconnectionstatechange = ()=> logUI('ICE: '+pc.iceConnectionState);
  pc.onconnectionstatechange = ()=> logUI('PC: '+pc.connectionState);
  const ls = await ensureLocal();
  ls.getTracks().forEach(t=> pc.addTrack(t, ls));
  preferVP8();
  pc.onnegotiationneeded = async () => { try { makingOffer = true; await pc.setLocalDescription(await pc.createOffer()); socket.emit('signal', {type:'sdp', description: pc.localDescription}); } finally { makingOffer = false; } };
}

socket.on('roles', ({polite, peerId})=>{ isPolite = !!polite; currentPartnerId = peerId; if (isBlocked(peerId)) setTimeout(()=> socket.emit('next'), 0); });
socket.on('waiting', m => addMessage(m));
function autoNext(){ setTimeout(()=>{ if (!hasPartner) socket.emit('next'); }, 2500); }

socket.on('partnerFound', async ()=>{ hasPartner = true; chat.textContent=''; addMessage('You found a new partner!'); if (!pc) await createPC(); const pub = await genECDH(); socket.emit('ecdh-public', pub); });
socket.on('partnerDisconnected', ()=>{ hasPartner=false; addMessage('Partner disconnected. Searching…'); autoNext(); });
socket.on('forceDisconnect', ()=>{ hasPartner=false; addMessage('Partner disconnected. Searching…'); autoNext(); });

socket.on('signal', async ({type, description, candidate})=>{
  if (!pc) await createPC();
  try {
    if (type === 'sdp') {
      const offerCollision = (description.type === 'offer') && (makingOffer || pc.signalingState !== 'stable');
      ignoreOffer = !isPolite && offerCollision;
      if (ignoreOffer) return;
      await pc.setRemoteDescription(description);
      while (pendingCandidates.length) { try { await pc.addIceCandidate(pendingCandidates.shift()); } catch {} }
      if (description.type === 'offer') {
        await ensureLocal();
        await pc.setLocalDescription(await pc.createAnswer());
        socket.emit('signal', {type:'sdp', description: pc.localDescription});
      }
    } else if (type === 'ice') {
      if (!pc.remoteDescription) pendingCandidates.push(candidate);
      else { try { await pc.addIceCandidate(candidate); } catch (err) { console.warn('addIceCandidate failed', err); } }
    }
  } catch (err) { console.warn('signal handling error', err); }
});

socket.on('ecdh-public', async (peer)=>{ try{ await importPeer(peer); document.getElementById('sendBtn').disabled=false; document.getElementById('messageInput').disabled=false; }catch{} });

socket.emit('setTopic', topic);

// Typing + chat
const typing = document.getElementById('typingIndicator');
socket.on('partnerTyping', ()=>{ if(!hasPartner) return; typing.textContent='Partner is typing...'; setTimeout(()=>typing.textContent='',1200); });
const sendBtn=document.getElementById('sendBtn');
const msgIn=document.getElementById('messageInput');
sendBtn.onclick = async ()=>{
  const txt = msgIn.value.trim();
  if(!txt || !hasPartner || !cryptoKey) return;
  const payload = await encryptText(txt);
  socket.emit('enc-message', payload);
  addMessage(txt, true);
  msgIn.value='';
};
msgIn.addEventListener('keypress', e=>{ if(e.key==='Enter') sendBtn.click(); else if(hasPartner) socket.emit('typing'); });
socket.on('enc-message', async (payload)=>{ try{ const text = await decryptText(payload); addMessage(text, false); }catch{} });

document.getElementById('blockBtn').onclick = ()=>{
  if(!currentPartnerId) return alert('No partner to block.');
  const s = getBlocked(); s.add(currentPartnerId); setBlocked(s);
  alert('Blocked. You won’t be matched with this user again.'); socket.emit('disconnectPartner');
};
document.getElementById('reportBtn').onclick = ()=>{
  if(!currentPartnerId) return alert('No partner to report.');
  socket.emit('report', { partnerId: currentPartnerId, topic });
  const s = getBlocked(); s.add(currentPartnerId); setBlocked(s);
  alert('Reported. You won’t be matched with this user again.'); socket.emit('disconnectPartner');
};

// Streamer mode
const streamBtn = document.getElementById('streamBtn');
let streamerOn = false, wm;
streamBtn.onclick = ()=>{
  streamerOn = !streamerOn;
  document.body.classList.toggle('streamer', streamerOn);
  streamBtn.textContent = 'Streamer: ' + (streamerOn ? 'On' : 'Off');
  if (streamerOn && !wm){
    wm = document.createElement('div'); wm.className = 'streamer-watermark'; wm.textContent = 'STREAMER MODE — chat hidden'; document.body.appendChild(wm);
  } else if (!streamerOn && wm){ wm.remove(); wm=null; }
};

socket.on('banned', ({untilISO})=>{ location.href = '/banned.html?until=' + encodeURIComponent(untilISO||''); });

if ('virtualKeyboard' in navigator) { navigator.virtualKeyboard.overlaysContent = true; }
document.getElementById('messageInput').addEventListener('focus', () => {
  setTimeout(()=> document.getElementById('chatMessages').scrollTop = 9e9, 250);
});

document.getElementById('nextBtn').onclick=()=>{ if (hasPartner) socket.emit('next'); else socket.emit('setTopic', topic); };
document.getElementById('disconnectBtn').onclick=()=>{ if (hasPartner) socket.emit('disconnectPartner'); hasPartner=false; location.href='/'; };
</script>
</body>
</html>
