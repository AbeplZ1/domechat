<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Domrcjst Chat</title>
  <link rel="stylesheet" href="styles.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <div id="topbar" aria-hidden="true">
    <div id="leftTop"><span class="small-text">follow domechat.live on TikTok</span></div>
    <div id="rightTop">
      <button id="ringLightToggle">Ring Light Off</button>
      <button id="miniGamesBtn">Mini Games</button>
    </div>
  </div>

  <div id="videoPlaceholder">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="ringLightOverlay"></div>
    <div id="asciiBackground"></div>
  </div>

  <div id="chatArea" aria-live="polite">
    <div id="chatMessages"></div>
    <div id="typingIndicator"></div>
    <div id="controlsRow">
      <input id="messageInput" placeholder="Type your message..." autocomplete="off" />
      <button id="sendBtn" disabled>Send</button>
    </div>
    <div id="bottomControls">
      <select id="colorSelector">
        <option value="white">White</option>
        <option value="color-green">Neon Green</option>
        <option value="color-pink">Pink</option>
        <option value="color-cyan">Cyan</option>
      </select>
      <select id="fontSelector">
        <option value="Share Tech Mono">Share Tech Mono</option>
        <option value="Press Start 2P">Press Start 2P</option>
      </select>
      <button id="soundToggle">Sound: On</button>
      <button id="saveChatBtn">Save Chat</button>
      <button id="nextBtn">Disconnect & Next</button>
      <button id="disconnectBtn">Disconnect</button>
    </div>
  </div>

  <!-- Mini Games Modal -->
  <div id="gameModal" class="modal" style="display:none;">
    <div class="modalContent">
      <h3>Mini Games</h3>
      <button id="rpsBtn">Rock Paper Scissors</button>
      <button id="closeGameBtn">Back to Chat</button>
      <div id="rpsUI" style="margin-top:10px;"></div>
    </div>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
/* ---------- Helpers ---------- */
const toB64 = (buf)=> btoa(String.fromCharCode(...new Uint8Array(buf)));
const fromB64 = (b64)=> {
  const bin = atob(b64); const arr = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr.buffer;
};

/* ---------- E2EE: ECDH + AES-GCM ---------- */
let cryptoKey=null, keyPair=null;
async function genECDH(){ 
  keyPair = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveKey']);
  const raw = await crypto.subtle.exportKey('raw', keyPair.publicKey);
  return toB64(raw);
}
async function importPeerAndDerive(peerB64){
  const raw = fromB64(peerB64);
  const peer = await crypto.subtle.importKey('raw', raw, {name:'ECDH', namedCurve:'P-256'}, true, []);
  cryptoKey = await crypto.subtle.deriveKey({name:'ECDH', public:peer}, keyPair.privateKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
}
async function encryptText(txt){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(txt);
  const c = await crypto.subtle.encrypt({name:'AES-GCM', iv}, cryptoKey, enc);
  return { iv: toB64(iv.buffer), data: toB64(c) };
}
async function decryptText(payload){
  const iv = fromB64(payload.iv);
  const data = fromB64(payload.data);
  const p = await crypto.subtle.decrypt({name:'AES-GCM', iv: iv.slice(0)}, cryptoKey, data);
  return new TextDecoder().decode(p);
}
async function shortAuthString(){
  // derive tiny fingerprint to compare verbally
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const probe = new TextEncoder().encode('domercjst'); // probe text
  const mac = await crypto.subtle.encrypt({name:'AES-GCM', iv}, cryptoKey, probe);
  const b = new Uint8Array(mac).slice(0,2);
  return [...b].map(x=>x.toString(16).padStart(2,'0')).join('').toUpperCase();
}

/* ---------- UI refs ---------- */
const chat = document.getElementById('chatMessages');
const msg = document.getElementById('messageInput');
const send = document.getElementById('sendBtn');
const typingIndicator = document.getElementById('typingIndicator');
const ringBtn = document.getElementById('ringLightToggle');
const ringOverlay = document.getElementById('ringLightOverlay');
const miniBtn = document.getElementById('miniGamesBtn');
const gameModal = document.getElementById('gameModal');
const closeGameBtn = document.getElementById('closeGameBtn');
const rpsBtn = document.getElementById('rpsBtn');
const rpsUI = document.getElementById('rpsUI');
const colorSel = document.getElementById('colorSelector');
const fontSel = document.getElementById('fontSelector');

/* ---------- Pairing ---------- */
const socket = io();
const params = new URLSearchParams(location.search);
const topic = params.get('topic') || '';
socket.emit('setTopic', topic);

/* ---------- WebRTC ---------- */
const ICE = {
  iceServers: [
    { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] }
    // Add TURN here for production
  ]
};
let pc=null, localStream=null;
const localVideo=document.getElementById('localVideo');
const remoteVideo=document.getElementById('remoteVideo');

async function startMedia(){
  try{
    localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    localVideo.srcObject = localStream;
  }catch(e){ addMessage('Camera/mic not available.'); }
}
async function createPC(){
  pc = new RTCPeerConnection(ICE);
  if (localStream) localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  pc.ontrack = ev => { if (ev.streams[0]) remoteVideo.srcObject = ev.streams[0]; };
  pc.onicecandidate = ev => { if (ev.candidate) socket.emit('signal', {type:'ice', candidate:ev.candidate}); };
}

socket.on('partnerFound', async () => {
  addMessage('Partner found! Establishing connection...');
  await startMedia();
  await createPC();
  const myPub = await genECDH(); socket.emit('ecdh-public', myPub);
  const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
  socket.emit('signal', {type:'sdp', description: offer});
});

socket.on('signal', async (data) => {
  if (!pc) await createPC();
  if (data.type === 'sdp') {
    const d = data.description;
    if (d.type === 'offer') {
      await pc.setRemoteDescription(d);
      const ans = await pc.createAnswer(); await pc.setLocalDescription(ans);
      socket.emit('signal', {type:'sdp', description: ans});
    } else if (d.type === 'answer') {
      await pc.setRemoteDescription(d);
    }
  } else if (data.type === 'ice') {
    try { await pc.addIceCandidate(data.candidate); } catch(e){}
  }
});

socket.on('ecdh-public', async (peer) => {
  await importPeerAndDerive(peer);
  const sas = await shortAuthString();
  addMessage('Encrypted text ready. Verify code: ' + sas);
  send.disabled = false; msg.disabled = false;
});

/* ---------- Text chat ---------- */
function addMessage(text, self=false){
  const d = document.createElement('div');
  d.textContent = text;
  if (self) d.classList.add('self');
  const t = document.createElement('span'); t.className='timestamp';
  t.textContent = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  d.appendChild(t);
  chat.appendChild(d); chat.scrollTop = chat.scrollHeight;
}
socket.on('enc-message', async (payload) => {
  try { const plain = await decryptText(payload); addMessage(plain,false); }
  catch {}
});
send.addEventListener('click', async () => {
  const txt = msg.value.trim(); if (!txt) return;
  if (txt.length > 1000) { alert('Message too long'); return; }
  addMessage(txt,true);
  const payload = await encryptText(txt);
  socket.emit('enc-message', payload);
  msg.value='';
});
msg.addEventListener('keypress', (e)=>{
  if (e.key==='Enter') send.click(); else socket.emit('typing');
});
socket.on('partnerTyping', () => {
  typingIndicator.textContent='Partner is typing...';
  setTimeout(()=> typingIndicator.textContent='', 1800);
});

/* ---------- UI toggles ---------- */
ringBtn.addEventListener('click', ()=>{
  const on = ringOverlay.classList.toggle('active');
  ringBtn.textContent = on ? 'Ring Light On' : 'Ring Light Off';
});
miniBtn.addEventListener('click', ()=> gameModal.style.display='block');
closeGameBtn.addEventListener('click', ()=> gameModal.style.display='none');

/* ---------- RPS ---------- */
rpsBtn.addEventListener('click', () => {
  rpsUI.innerHTML = `
    <div>Pick: <button data-m="rock">Rock</button>
    <button data-m="paper">Paper</button>
    <button data-m="scissors">Scissors</button></div>
    <div id="rpsResult" style="margin-top:8px;"></div>`;
  rpsUI.querySelectorAll('button[data-m]').forEach(b => b.onclick=()=>{
    socket.emit('rpsMove', b.dataset.m);
    document.getElementById('rpsResult').textContent='Waiting for partner...';
  });
});
socket.on('rpsRoundResult', (r) => {
  const e = document.getElementById('rpsResult'); if (!e) return;
  e.textContent = `You: ${r.yourMove} | Partner: ${r.partnerMove} â€” ${r.winner==='you'?'You win':r.winner==='partner'?'You lose':'Tie'}`;
});

/* ---------- Save / Disconnect ---------- */
document.getElementById('saveChatBtn').addEventListener('click', ()=>{
  let t=''; chat.querySelectorAll('div').forEach(d=> t+=d.textContent+'\n');
  const blob = new Blob([t], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download='domechat_transcript.txt'; a.click();
});
document.getElementById('nextBtn').addEventListener('click', ()=>{
  socket.emit('disconnectPartner'); chat.textContent=''; socket.emit('setTopic', topic);
});
document.getElementById('disconnectBtn').addEventListener('click', ()=>{
  socket.emit('disconnectPartner'); location.href='/';
});

/* ---------- ASCII bg ---------- */
(function genAscii(){
  const el = document.getElementById('asciiBackground');
  const rows=40, cols=70, chars=['#','@','%','*','+','=','-','~'];
  let lines=[];
  for (let i=0;i<rows;i++){
    let line='';
    for (let j=0;j<cols;j++) line += chars[Math.floor(Math.random()*chars.length)];
    lines.push(line);
  }
  el.textContent = lines.join('\n');
})();
</script>
</body>
</html>
